# utp2017-6-graph2d
Приложение для интерактивного отображения двумерных графиков функций

## Участники
* [Чугунов Денис](https://github.com/Praepostor-IU9) (старший) — @Praepostor-IU9
* [Масягин Михаил](https://github.com/masyagin1998) — @masyagin1998
* [Барлука Александр](https://github.com/Nexterot) — @Nexterot
* [Фадеев Виктор](https://github.com/Roninsc2) — @Roninsc2
* [Зашихин Данил](https://github.com/andWhatShouldISay) — @andWhatShouldISay

## Распределение ролей
**1) Построение графика функции одной переменной:**
  * [Фадеев Виктор](https://github.com/Roninsc2);
  * [Зашихин Данил](https://github.com/andWhatShouldISay);
  
**2) Построение графика функции двух переменных:**
  * [Чугунов Денис](https://github.com/Praepostor-IU9) - Алгоритм построения линий уровня;
  * [Масягин Михаил](https://github.com/masyagin1998) - Алгоритм поиска частных производных для построения линий уроня;
  * [Масягин Михаил](https://github.com/masyagin1998) - Вспомогателные алгоритмы:
  
    а) Сопоставление координат графика функции к координатам canvas.
    
    б) Построение осей координат и сетки.
    
    в) Определения цвета у линии уровня заданной высоты.
    
**3) Разработка дизайна:**
  [Барлука Александр](https://github.com/Nexterot);

## Описание программы
* **График функции двух переменных**

[Первый метод (метод сканирования)](https://github.com/bmstu-iu9/utp2017-6-graph2d/tree/featurePlane2dPixel):

В алгоритме метода сканирования (построчной развертки) функция f(x, y) "просматривается" с достаточно малыми шагами hx, hy строка за строкой в пределах заданных границ ax≤x≤bx, ay≤y≤by, и всякий раз, когда значение функции z=f(x, y) на текущем шаге строки переходит из одного интервала уровней в другой, на карте изображается точка.

[Второй метод (метод трассировки)](https://github.com/bmstu-iu9/utp2017-6-graph2d/tree/featurePlane2dDerivative):

Алгоритм строит изолинию по заданному уровню. Для приближенного изображения изолинии можно заменить её ломаной линией, выбирая достаточно малый шаг. Чтобы избежать накопления ошибок, целесообразно построить ломаную, вписанную в интересующую нас изолинию. Каждое звено такой ломаной можно получить, перемещаясь сначала по касательной к изолинии, а затем "возвращаясь" на изолинию, то есть переходя к ближайшей точке с заданным уровнем значений функции.

[Третий метод](https://github.com/bmstu-iu9/utp2017-6-graph2d/tree/featurePlane3dLine):

Алоритм схож с первым методом (метод сечения). По выбранному шагу производится обход графика вначале по оси y, а затем по оси x. Существенным отличием является то, что график строится не в виде изолиний на плоскоти, а в виде полноценного трехмерного графика.

* **График функции одной переменной**

Алгоритм:

На вход подается выражение в заданной лексике и интервал переменной, на котором будет рассмотрена данная функция. Далее происходит лексический разбор выражения, создаются команды, результат выполнения данных команд будет положен на стэк. Конечный результат - это массивы точек x и точек f(x). Алгоритм находит область определния и область значения данной функции, затем учитывает эту информацию при отрисовке графика.

Лексика (пробелов быть не должно):
* Функция: function(val) или function(val,val) или function()
* Переменная: x
* Число: [число]
* val: Функция или Число или Переменная

Доступные функции:
* sin(val) - синус val
* cos(val) - косинус val
* tg(val) - тангенс val
* ctg(val) - котангес val
* arcsin(val) - арксинус val
* arccos(val) - арккосинус val
* arctg(val) - арктангес val
* arcctg(val) - арккотангенс val
* abs(val) - модуль val
* pow(val1,val2) - степенная функция (val1 ^ val2)
* plus(val1,val2) - плюс (val1 + val2)
* minus(val1,val2) - минус (val1 - val2)
* mult(val1,val2) - умножение (val1 * val2)
* div(val1,val2) - деление (val1 / val2)
* log(val1,val2) - логарифм val2 по основанию val1
* pi() - число pi
* e() - число e 

## Назначение ветки
В данную ветку будут сливаться все функциональные ветки для следующего релиза.
